#!/bin/env python
"""
Module for calibrating stereo cameras from a images with chessboards.

See stereo_match.py in the OpenCV examples for some additional tips on
converting the generated 3D coordinates into a point cloud. I borrowed some
numpy magic from there.
"""

import argparse
import os

import cv2

import chessboard_photos
import numpy as np


class ChessboardNotFoundError(Exception):
    """No chessboard could be found in searched image."""


def show_image(image, window_name, wait=0):
    """Show an image and exit when a key is pressed or specified wait period."""
    cv2.imshow(window_name, image)
    if cv2.waitKey(wait):
        cv2.destroyWindow(window_name)


def find_files(folder):
    """Discover stereo photos and return them as a pairwise sorted list."""
    files = [i for i in os.listdir(folder) if i.startswith("left")]
    files.sort()
    for i in range(len(files)):
        insert_string = "right{}".format(files[i * 2][4:])
        files.insert(i * 2 + 1, insert_string)
    files = [os.path.join(folder, filename) for filename in files]
    return files


class StereoCalibrator(object):
    """A class that calibrates stereo cameras."""
    def __init__(self, rows, columns, square_size, image_size):
        """
        Store variables relevant to the camera calibration.

        ``corner_coordinates`` are generated by creating an array of 3D
        coordinates that correspond to the actual positions of the chessboard
        corners observed on a 2D plane in 3D space.
        """
        #: Number of calibration images
        self.image_count = 0
        #: Number of inside corners in the chessboard's rows
        self.rows = rows
        #: Number of inside corners in the chessboard's columns
        self.columns = columns
        #: Size of chessboard squares in cm
        self.square_size = square_size
        #: Size of calibration images in pixels
        self.image_size = image_size
        pattern_size = (self.rows, self.columns)
        corner_coordinates = np.zeros((np.prod(pattern_size), 3), np.float32)
        corner_coordinates[:, :2] = np.indices(pattern_size).T.reshape(-1, 2)
        corner_coordinates *= self.square_size
        #: Real world corner coordinates found in each image
        self.corner_coordinates = corner_coordinates
        #: Array of real world corner coordinates to match the corners found
        self.object_points = []
        #: Array of found corner coordinates from calibration images for left
        #: and right camera, respectively
        self.image_points = {"left": [], "right": []}
    def get_corners(self, image):
        """Find subpixel chessboard corners in image."""
        temp = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)
        ret, corners = cv2.findChessboardCorners(temp,
                                                 (self.rows, self.columns))
        if not ret:
            raise ChessboardNotFoundError("No chessboard could be found.")
        cv2.cornerSubPix(temp, corners, (11, 11), (-1, -1),
                         (cv2.TERM_CRITERIA_MAX_ITER + cv2.TERM_CRITERIA_EPS,
                          30, 0.01))
        return corners
    def show_corners(self, image, corners):
        """Show chessboard corners found in image."""
        temp = image
        cv2.drawChessboardCorners(temp, (self.rows, self.columns), corners,
                                  True)
        show_image(temp, "Chessboard")
    def add_corners(self, image_pair, show_results=False):
        """
        Record chessboard corners found in an image pair.

        The image pair should be an iterable composed of two CvMats ordered
        (left, right).
        """
        side = "left"
        self.object_points.append(self.corner_coordinates)
        for image in image_pair:
            corners = self.get_corners(image)
            if show_results:
                self.show_corners(image, corners)
            self.image_points[side].append(corners.reshape(-1, 2))
            side = "right"
            self.image_count += 1
    def calibrate_cameras(self):
        """Calibrate cameras based on found chessboard corners."""
        (retval, cameraMatrix1, distCoeffs1, cameraMatrix2, distCoeffs2,
         R, T, E, F) = cv2.stereoCalibrate(self.object_points,
                                           self.image_points["left"],
                                           self.image_points["right"],
                                           self.image_size,
                                       criteria=(cv2.TERM_CRITERIA_MAX_ITER +
                                                 cv2.TERM_CRITERIA_EPS,
                                                 100, 1e-5),
                                           flags=(cv2.CALIB_FIX_ASPECT_RATIO +
                                                  cv2.CALIB_ZERO_TANGENT_DIST +
                                                  cv2.CALIB_SAME_FOCAL_LENGTH))
        return (cameraMatrix1, distCoeffs1, cameraMatrix2, distCoeffs2,
                R, T, E, F)


def main():
    """Read all images in input folder and produce camera calibration files."""
    # TODO: Include option for showing disparity pictures
#    parser = argparse.ArgumentParser(description="Read images taken with "
#                                     "stereo pair and use them to compute "
#                                     "camera calibration.",
#                             parents=[chessboard_photos.CHESSBOARD_ARGUMENTS])
#    parser.add_argument("square_size", help="Size of chessboard squares in cm.")
#    parser.add_argument("input_folder", help="Input folder assumed to contain "
#                        "only stereo images taken with the stereo camera pair "
#                        "that should be calibrated.",
#                        )
#    parser.add_argument("output_folder", help="Folder to write calibration XML "
#                        "files to.", default="/tmp/")
#    parser.add_argument("--show-chessboards", help="Display detected "
#                        "chessboard corners.", action="store_true")
#    args = parser.parse_args()

    # TODO: These are fake arguments used for testing
    args = argparse.ArgumentParser()
    args.input_folder = "/home/lee/development/eclipse/opencv-experiments/data/calibration_pictures"
    args.rows, args.columns, args.square_size = 9, 6, 1.8
    args.show_chessboards = False

    input_files = find_files(args.input_folder)
    height, width = cv2.imread(input_files[0]).shape[:2]
    calibrator = StereoCalibrator(args.rows, args.columns, args.square_size,
                                  (width, height))
    # Consume input_files, reading the images and passing them to the calibrator
    # to store the corners.
    while input_files:
        left, right = input_files[:2]
        img_left, im_right = cv2.imread(left), cv2.imread(right)
        calibrator.add_corners((img_left, im_right),
                               show_results=args.show_chessboards)
        input_files = input_files[2:]
    calibrator.calibrate_cameras()
    """
    I've got a choice here of how I should build this. I could go object
    oriented or just use functions. Not sure what would be the most elegant.
    Here's the steps:
    1. Find the chessboard corners and store them somewhere
    2. Reorganize the image points into some matrices
    3. Calibrate the cameras
    4. Check the quality of the camera calibration
    5. Save the calibration to file
    6. Rectify images and show disparity maps, apparently because we can

    This doesn't sound like it would be too hard to make as a class. Perhaps
    one that takes the input folder and then computes the corners for each
    picture. Lots of helper methods. And at the end of it all it could spit
    out the calibration matrices or save them to file, however you want it.
    Otherwise it'd all be stored.
    """

if __name__ == "__main__":
    main()
