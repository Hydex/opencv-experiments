#!/bin/env python
"""
Module for calibrating stereo cameras from a images with chessboards.

See stereo_match.py in the OpenCV examples for some additional tips on
converting the generated 3D coordinates into a point cloud. I borrowed some
numpy magic from there.
"""

import argparse
import os

import cv2

import chessboard_photos
import numpy as np


class ChessboardNotFoundError(Exception):
    """No chessboard could be found in searched image."""


def show_image(image, window_name, wait=0):
    """Show an image and exit when a key is pressed or specified wait period."""
    cv2.imshow(window_name, image)
    if cv2.waitKey(wait):
        cv2.destroyWindow(window_name)


def find_files(folder):
    """Discover stereo photos and return them as a pairwise sorted list."""
    files = [i for i in os.listdir(folder) if i.startswith("left")]
    files.sort()
    for i in range(len(files)):
        insert_string = "right{}".format(files[i * 2][4:])
        files.insert(i * 2 + 1, insert_string)
    files = [os.path.join(folder, filename) for filename in files]
    return files


class StereoCalibrator(object):
    """A class that calibrates stereo cameras."""
    def __init__(self, rows, columns, square_size):
        """
        Store variables relevant to the camera calibration.

        ``corner_coordinates`` are generated by creating an array of 3D
        coordinates that correspond to the actual positions of the chessboard
        corners observed on a 2D plane in 3D space.
        """
        # : Number of calibration images
        self.image_count = 0
        # : Number of inside corners in the chessboard's rows
        self.rows = rows
        # : Number of inside corners in the chessboard's columns
        self.columns = columns
        # : Size of chessboard squares in cm
        self.square_size = square_size
        pattern_size = (self.columns, self.rows)
        corner_coordinates = np.zeros((np.prod(pattern_size), 3), np.float32)
        corner_coordinates[:, :2] = np.indices(pattern_size).T.reshape(-1, 2)
        corner_coordinates *= self.square_size
        # : Real world corner coordinates found in each image
        self.corner_coordinates = corner_coordinates
        # : Array of corner coordinates to match the corners found.
        self.object_points = []
    # TODO: Add method to load the corners from all images. Every time you do
    # so, increment image_count. You'll need the corners later.
    def add_corners(self, image_pair):
        """Record chessboard corners found in an image pair."""
        self.image_count += 1
    def get_corners(self, image):
        """Find subpixel chessboard corners in image."""
        temp = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)
        ret, corners = cv2.findChessboardCorners(temp,
                                                 (self.rows, self.columns))
        if not ret:
            raise ChessboardNotFoundError("No chessboard could be found.")
        cv2.cornerSubPix(temp, corners, (11, 11), (-1, -1),
                         (cv2.TERM_CRITERIA_MAX_ITER + cv2.TERM_CRITERIA_EPS,
                          30, 0.01))
        return corners
    def show_corners(self, image, corners):
        """Show chessboard corners found in image."""
        temp = image
        cv2.drawChessboardCorners(temp, (self.rows, self.columns), corners,
                                  True)
        show_image(temp, "Chessboard")
    def calibrate_cameras(self, image_list):
        """
        Calibrate cameras based on found chessboard corners.

        First, the real world coordinates of all chessboard corners are
        generated as a list of 3D coordinates on a 2D plane. The list is
        repeated to provide the real world coordinates for each point found in
        every image pair.

        Then the real world coordinates and the picture coordinates for each
        image are transformed into CvMats with the same dimensions in order to
        be passed to cv2.StereoCalibrate.
        """
        # See stereo_calibrate.cpp, line 240, to see how this is done.
        # Beforehand all the stuff is sorted into weird matrices, see lines
        # 228-231. The variables in the C file M1, D1, M2 and D2 are the
        # respective cameras' camera matrices and distortion coefficients.
        #
        # Now I'm making the objectPoints. These are the actual coordinates of
        # the corners observed on a 2d plane embedded in 3d space. Pretty simple
        # and I'm using some cheat variables for making sure that I'm matching
        # what the C program outputs.


        # This is just for testing purposes, I'm far from finished. What this is
        # is the coordinates of the chessboard corners on a 2d plane in a 3d
        # space with 0 along the x along the z axis. I'm returning it right now
        # so I can check it out, but what I'm really interested in is returning
        # all the calibration stuff that's in the lines below. And... It's
        # tested and it works! real_corner_coordinates is the same as the vector
        # of 3d coordinates produced on lines 221-248 (with my comments) in
        # stereo_calibrate.cpp.
#         (retval, cameraMatrix1, distCoeffs1, cameraMatrix2, distCoeffs2,
#          R, T, E, F) = cv2.stereoCalibrate(objectPoints,
#                                            imagePoints1,
#                                            imagePoints2,
#                                            imageSize,
#                                        criteria=(cv2.TERM_CRITERIA_MAX_ITER +
#                                                  cv2.TERM_CRITERIA_EPS,
#                                                  100, 1e-5),
#                                            flags=(cv2.CALIB_FIX_ASPECT_RATIO +
#                                                   cv2.CALIB_ZERO_TANGENT_DIST +
#                                                   cv2.CALIB_SAME_FOCAL_LENGTH))
#         return (cameraMatrix1, distCoeffs1, cameraMatrix2, distCoeffs2,
#                 R, T, E, F)


def main():
    """Read all images in input folder and produce camera calibration files."""
    parser = argparse.ArgumentParser(description="Read images taken with "
                                     "stereo pair and use them to compute "
                                     "camera calibration.",
                             parents=[chessboard_photos.CHESSBOARD_ARGUMENTS])
    parser.add_argument("square_size", help="Size of chessboard squares in cm.")
    parser.add_argument("input_folder", help="Input folder assumed to contain "
                        "only stereo images taken with the stereo camera pair "
                        "that should be calibrated.",
                        )
    parser.add_argument("output_folder", help="Folder to write calibration XML "
                        "files to.", default="/tmp/")
    args = parser.parse_args()

    args = argparse.ArgumentParser()
    args.input_folder = "/home/lee/development/eclipse/opencv-experiments/data/calibration_pictures"
    args.rows, args.columns, args.square_size = 9, 6, 1.8
    calibrator = StereoCalibrator(args.rows, args.columns, args.square_size)
    input_files = find_files(args.input_folder)
    for input_file in input_files:
        img = cv2.imread(input_file)
        crns = calibrator.get_corners(img)
        calibrator.show_corners(img, crns)

    """
    I've got a choice here of how I should build this. I could go object
    oriented or just use functions. Not sure what would be the most elegant.
    Here's the steps:
    1. Find the chessboard corners and store them somewhere
    2. Reorganize the image points into some matrices
    3. Calibrate the cameras
    4. Check the quality of the camera calibration
    5. Save the calibration to file
    6. Rectify images and show disparity maps, apparently because we can

    This doesn't sound like it would be too hard to make as a class. Perhaps
    one that takes the input folder and then computes the corners for each
    picture. Lots of helper methods. And at the end of it all it could spit
    out the calibration matrices or save them to file, however you want it.
    Otherwise it'd all be stored.
    """

if __name__ == "__main__":
    main()
